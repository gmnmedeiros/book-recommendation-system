# -*- coding: utf-8 -*-
"""Book-Recommender.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KkF-8SBZeYqBDy8ekcRPSji-yUJTVATN

# Intro

In this notebook we will implement a recommendation algorithm for books.

As method, we will use "colaborative filtering", in which we find common interests among users and recommend books based on said similarities.

Dataset available on https://www.kaggle.com/ruchi798/bookcrossing-dataset
"""

import numpy as np
import pandas as pd

books = pd.read_csv("/content/BX_Books.csv", encoding='latin-1', error_bad_lines=False, sep=';')
ratings = pd.read_csv("/content/BX-Book-Ratings.csv", encoding='latin-1', error_bad_lines=False, sep=';')

books.columns = ['ISBN', 'bookTitle', 'bookAuthor', 'yearOfPublication', 'publisher', 'imageUrlS', 'imageUrlM', 'imageUrlL']

ratings.columns = ['userID', 'ISBN', 'bookRating']

ratings = ratings.set_index("ISBN")

books = books.set_index("ISBN")

books.head()

ratings.tail()

"""---

# Distance between users

First we must implement a distance function in order to understand how close the interests of two users are.

For this, we will use NumPy's `linalg.norm`
"""

def array_distance(a,b):
  return np.linalg.norm(a - b)

# Testing function

a=np.array([3, 4, 5, 3, 2, 4])
b = np.array([4, 4, 4, 3, 2, 2])

array_distance(a, b)

"""The above output represents the distance between the points in both arrays. 

This is the core idea of the distance between users ratings on movies.

**That being said, let's grab the users ratings**
"""

def ratings_from_user(userID):
  ratings_from_user = ratings.query("userID==%d" % userID)
  ratings_from_user = ratings_from_user[["bookRating"]]
  return ratings_from_user

#Testing
ratings_from_user(276704)

"""**Now, let's use the above functions to get the distance between two users.**"""

distance_test = ratings_from_user(276729).join(ratings_from_user(276729), rsuffix="_A", lsuffix="_B")

array_distance(distance_test["bookRating_B"], distance_test['bookRating_A'])

"""Although the result is misleading (both users actually have nothing in common, and this issue will be soon addressed), we can see that **the distance function actually works**.

Let's define a function that outputs the distance between two users.
"""

def distance_between_users(user1:int, user2:int): # parameters = int
  ratings_from_user1 = ratings_from_user(user1)
  ratings_from_user2 = ratings_from_user(user2)
  # Above we create dataframes for each user

  #Bellow we join both dataframes
  both_ratings = ratings_from_user1.join(ratings_from_user2, lsuffix="_A", rsuffix="_B").dropna()

  #Now we return the distance between the columns of each dataframe
  distance = array_distance(both_ratings["bookRating_A"], both_ratings["bookRating_B"])

  return [user1, user2, distance]

#Test
distance_between_users(276729, 276704)

"""It works! Same output as before.

---

# Find most similar user

It is very time consuming to keep analyzing pairs of random users. **It is more valuable for us to find the K most similar users**

(Or our "k-nearest-neighbors" if you will)
"""

print ("We have %d users" %len(ratings["userID"].unique()))

def distance_from_all(targetID:int):
  all_users = ratings["userID"].unique()[:3000] #since we have 105k+ users, we need to select a smaller sample. 2k will do.

  distances = [distance_between_users(targetID, users) for users in all_users]

  distances = pd.DataFrame(distances, columns = ["targetID", "otherUserID", "distance"])

  return distances.set_index("otherUserID").sort_values("distance").query("distance>0")

distance_from_all(276704)

"""---

# Suggest books based on closest users

This function bellow calls the distance_from_all functions and filters the best matches. Then, it joins the best matches' ratings and suggest books based on them.
"""

def suggest_to(userID:int):
  #user_ratings = ratings_from_user(userID)
  #books_read_by_user = user_ratings.index

  similar_users = distance_from_all(userID).head(3)
  similar_users_list = similar_users.index
  
  ratings_from_similar_users = ratings[ratings["userID"].isin(similar_users_list)]

  suggestions = ratings_from_similar_users.groupby("ISBN").mean()[["bookRating"]]
  suggestions = suggestions.sort_values("bookRating", ascending=False)

  

  return suggestions.join(books[["bookTitle", "bookAuthor", "yearOfPublication"]])

suggest_to(276704)

"""## Final thoughts 

There is, obviously, room for optimization. It is possible to test with different samples of the data. Also, we can tune the functions to reduce the processing time, for it is not quite fast.

Thank you for reading this notebook!

You can reach me out on github.com/gmnmedeiros/gmnmedeiros
"""



